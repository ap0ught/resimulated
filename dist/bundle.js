!function(e){var n={};function r(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)r.d(t,o,function(n){return e[n]}.bind(null,o));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s=0)}([function(e,n,r){"use strict";class t{constructor(){const e=document.createElement("canvas");e.width=512,e.height=512,e.style.border="solid",window.document.body.appendChild(e);const n=e.getContext("webgl2");n.enable(n.CULL_FACE);const t=[[1,1],[-1,1],[1,-1],[-1,-1]],o=new Float32Array([].concat(...t)),i=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,i),n.bufferData(n.ARRAY_BUFFER,o,n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null);const a=[[0,1,2],[3,2,1]],l=new Uint16Array([].concat(...a)),u=n.createBuffer();n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,u),n.bufferData(n.ELEMENT_ARRAY_BUFFER,l,n.STATIC_DRAW),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null);const c={iResolution:{type:"vec3",value:[512,512,0]},iTime:{type:"float",value:0},iTimeDelta:{type:"float",value:0},iFrame:{type:"int",value:0},iMouse:{type:"vec4",value:[0,0,0,0]}},f=n.createVertexArray(),m=(e,r)=>{const t=n.createShader(r);return n.shaderSource(t,e),n.compileShader(t),n.getShaderParameter(t,n.COMPILE_STATUS)||console.log(e,n.getShaderInfoLog(t)),t};(()=>Promise.all([m(r(1).default,n.VERTEX_SHADER),m(r(2).default,n.FRAGMENT_SHADER)]).then(e=>{const r=n.createProgram();return e.forEach(e=>n.attachShader(r,e)),n.linkProgram(r),n.getProgramParameter(r,n.LINK_STATUS)||console.log(n.getProgramInfoLog(r)),r}))().then(e=>((e=>{n.bindVertexArray(f),n.bindBuffer(n.ARRAY_BUFFER,i),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,u);const r=n.getAttribLocation(e,"vert2d"),o=n.FLOAT,a=t[0].length,l=a*Float32Array.BYTES_PER_ELEMENT;n.enableVertexAttribArray(r),n.vertexAttribPointer(r,a,o,!1,l,0),n.bindVertexArray(null)})(e),(e=>{Object.keys(c).forEach((r,t)=>{c[r].location=n.getUniformLocation(e,r)})})(e),e)).then(e=>{let r=0;const t=o=>{((e,r,t)=>{n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.useProgram(e),c.iTime.value=.001*r,c.iTimeDelta.value=.001*(r-t),c.iFrame.value++,Object.keys(c).forEach(e=>{const r=c[e].type,t=r.match(/vec/)?`${r[r.length-1]}fv`:`1${r[0]}`;n[`uniform${t}`](c[e].location,c[e].value)}),n.bindVertexArray(f);const o=0*a[0].length;n.drawElements(n.TRIANGLES,l.length,n.UNSIGNED_SHORT,o);const i=n.getError();i!==n.NO_ERROR&&console.log(i),n.bindVertexArray(null),n.useProgram(null)})(e,o,r),requestAnimationFrame(t),r=o};t()})}}window.addEventListener("load",e=>{new t},!1)},function(e,n,r){"use strict";r.r(n),n.default="#version 300 es\n\ninvariant gl_Position;\nin vec2 vert2d;\n\nvoid main(void) {\n  gl_Position = vec4(vert2d, 0, 1);\n}\n"},function(e,n,r){"use strict";r.r(n),n.default="#version 300 es\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\nprecision mediump sampler3D;\n#endif\n#define HW_PERFORMANCE 1\nuniform vec3      iResolution;\nuniform float     iTime;\nuniform float     iChannelTime[4];\nuniform vec4      iMouse;\nuniform vec4      iDate;\nuniform float     iSampleRate;\nuniform vec3      iChannelResolution[4];\nuniform int       iFrame;\nuniform float     iTimeDelta;\nuniform float     iFrameRate;\nstruct Channel\n{\n    vec3  resolution;\n    float time;\n};\nuniform Channel iChannel[4];\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\nvoid mainImage( out vec4 c,  in vec2 f );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nout vec4 outColor;\nvoid main( void ){vec4 color = vec4(0.0,0.0,0.0,1.0);mainImage( color, gl_FragCoord.xy );color.w = 1.0;outColor = color;}"}]);