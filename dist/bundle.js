!function(n){var e={};function t(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return n[i].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)t.d(i,o,function(e){return n[e]}.bind(null,o));return i},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=10)}([function(n,e,t){"use strict";t.r(e),e.default="#version 300 es\n\ninvariant gl_Position;\nin vec2 vert2d;\n\nvoid main(void) { gl_Position = vec4(vert2d, 0, 1); }\n"},function(n,e,t){"use strict";t.r(e),e.default="#version 300 es\nprecision highp float;\nprecision highp int;\nprecision mediump sampler3D;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\n\nout vec4 outColor;\nvoid main(void) {\n    vec4 c;\n    mainImage(c, gl_FragCoord.xy);\n    outColor = c;\n}\n\n// consts\nconst float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\nconst float PIH = 1.57079632679;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nuniform vec3 iResolution;\nuniform float iTime;\nuniform sampler2D iPrevPass;\n\n// noise\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 tap4(sampler2D tex, vec2 uv, vec2 texelSize) {\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n    vec3 s;\n    s = texture(tex, uv + d.xy).rgb;\n    s += texture(tex, uv + d.zy).rgb;\n    s += texture(tex, uv + d.xw).rgb;\n    s += texture(tex, uv + d.zw).rgb;\n\n    return s * (1.0 / 4.0);\n}\n\n#define BPM 140.0\n#define beat (iTime * BPM / 60.0)\n"},function(n,e,t){"use strict";t.r(e),e.default="// debug uniforms\nuniform float gCameraEyeX;     // 0 -100 100\nuniform float gCameraEyeY;     // 2.8 -100 100\nuniform float gCameraEyeZ;     // -8 -100 100\nuniform float gCameraTargetX;  // 0 -100 100\nuniform float gCameraTargetY;  // 2.75 -100 100\nuniform float gCameraTargetZ;  // 0 -100 100\nuniform float gCameraFov;      // 13 0 180\n\nuniform float gMandelboxScale;     // 2.7 1 5\nuniform float gMandelboxRepeat;    // 10 1 100\nuniform float gSceneEps;           // 0.001 0.00001 0.01\nuniform float gEdgeEps;            // 0.0005 0.0001 0.01\nuniform float gEdgePower;          // 1 0.1 10\nuniform float gBaseColor;          // 0.5\nuniform float gRoughness;          // 0.1\nuniform float gMetallic;           // 0.4\nuniform float gEmissiveIntensity;  // 6.0 0 20\n\nuniform float gSceneId;  // 0 0 2\n#define SCENE_MANDEL 0.0\n#define SCENE_UNIVERSE 1.0\n\nuniform sampler2D iTextTexture;\n\n// consts\nconst float INF = 1e+10;\nconst float OFFSET = 0.1;\n\n// ray\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// camera\nstruct Camera {\n    vec3 eye, target;\n    vec3 forward, right, up;\n};\n\nRay cameraShootRay(Camera c, vec2 uv) {\n    c.forward = normalize(c.target - c.eye);\n    c.right = normalize(cross(c.forward, c.up));\n    c.up = normalize(cross(c.right, c.forward));\n\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(uv.x * c.right + uv.y * c.up + c.forward / tan(gCameraFov / 360.0 * PI));\n\n    return r;\n}\n\n// intersection\nstruct Intersection {\n    bool hit;\n    vec3 position;\n    float distance;\n    vec3 normal;\n    vec2 uv;\n    float count;\n\n    vec3 baseColor;\n    float roughness;\n    float reflectance;\n    float metallic;\n    vec3 emission;\n\n    bool transparent;\n    float refractiveIndex;\n\n    vec3 color;\n};\n\n// util\n#define calcNormal(p, dFunc, eps)                                                                                                                                                 \\\n    normalize(vec2(eps, -eps).xyy *dFunc(p + vec2(eps, -eps).xyy) + vec2(eps, -eps).yyx * dFunc(p + vec2(eps, -eps).yyx) + vec2(eps, -eps).yxy * dFunc(p + vec2(eps, -eps).yxy) + \\\n              vec2(eps, -eps).xxx * dFunc(p + vec2(eps, -eps).xxx))\n\n// Distance Functions\nfloat dSphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rotate(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat dMandelFast(vec3 p, float scale, int n) {\n    vec4 q0 = vec4(p, 1.0);\n    vec4 q = q0;\n\n    for (int i = 0; i < n; i++) {\n        // q.xz = mul(rotate(_MandelRotateXZ), q.xz);\n        q.xyz = clamp(q.xyz, -1.0, 1.0) * 2.0 - q.xyz;\n        q = q * scale / clamp(dot(q.xyz, q.xyz), 0.3, 1.0) + q0;\n    }\n\n    return length(q.xyz) / abs(q.w);\n}\n\nvec2 foldRotate(vec2 p, float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = TAU / s;\n    a = floor(a / n) * n;\n    p = rotate(a) * p;\n    return p;\n}\n\nuniform float gFoldRotate;  // 1 0 20\n\nfloat dStage(vec3 p) {\n    float b = max(beat - 128.0, 0.0) + (p.z + 10.0);\n    p.xy = foldRotate(p.xy, gFoldRotate);\n    return dMandelFast(p, gMandelboxScale, int(gMandelboxRepeat));\n}\n\nuniform float gBallZ;               // 0 -100 100\nuniform float gBallRadius;          // 0.1 0 0.2\nuniform float gBallDistortion;      // 0.0 0 0.1\nuniform float gBallDistortionFreq;  // 0 0 100\n\nfloat dBall(vec3 p) {\n    return dSphere(p - vec3(0, 0, gBallZ), gBallRadius) - gBallDistortion * sin(gBallDistortionFreq * p.x + beat) * sin(gBallDistortionFreq * p.y + beat) * sin(gBallDistortionFreq * p.z + beat);\n}\n\nvec3 opRep(vec3 p, vec3 c) { return mod(p, c) - 0.5 * c; }\n\nfloat map(vec3 p) {\n    float d = INF;\n\n    if (gSceneId == SCENE_MANDEL) {\n        d = dStage(p);\n    };\n\n    if (gBallRadius > 0.0) {\n        d = min(d, dBall(p));\n    }\n\n    return d;\n}\n\n// color functions\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\n// https://www.shadertoy.com/view/lttGDn\nfloat calcEdge(vec3 p) {\n    float edge = 0.0;\n    vec2 e = vec2(gEdgeEps, 0);\n\n    // Take some distance function measurements from either side of the hit\n    // point on all three axes.\n    float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n    float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n    float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    float d = map(p) * 2.;  // The hit point itself - Doubled to cut down on\n                            // calculations. See below.\n\n    // Edges - Take a geometry measurement from either side of the hit point.\n    // Average them, then see how much the value differs from the hit point\n    // itself. Do this for X, Y and Z directions. Here, the sum is used for the\n    // overall difference, but there are other ways. Note that it's mainly sharp\n    // surface curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    // edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); //\n    // Etc.\n\n    // Once you have an edge value, it needs to normalized, and smoothed if\n    // possible. How you do that is up to you. This is what I came up with for\n    // now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge / e.x * 2.));\n\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return edge;\n}\n\n// Thanks https://shadertoy.com/view/ttsGR4\nfloat revisionLogo(vec2 p, float rot) {\n    int[] pat = int[](0, ~0, 0x7C, 0xC0F03C00, 0xF7FBFF01, ~0, 0, 0x8320D39F, ~0, 0x1F0010, 0);\n    int r = clamp(int(20. * length(p)), 0, 10);\n    return float(pat[r] >> int(5.1 * atan(p.y, p.x) + 16. + (hash11(float(r * 1231)) - 0.5) * rot) & 1);\n}\n\nuniform float gEmissiveSpeed;  // 1 0 2\nuniform float gLogoIntensity;  // 0 0 4\n\nuniform float gEmissiveHue;           // 0.33947042613522904 0 1\nuniform float gEmissiveHueShiftBeat;  // 0 0 1\nuniform float gEmissiveHueShiftZ;     // 0 0 1\nuniform float gEmissiveHueShiftXY;    // 0 0 1\n\nvoid intersectObjects(inout Intersection intersection, inout Ray ray) {\n    float d;\n    float distance = 0.0;\n    vec3 p = ray.origin;\n    float eps;\n\n    for (float i = 0.0; i < 300.0; i++) {\n        d = abs(map(p));\n        distance += d;\n        p = ray.origin + distance * ray.direction;\n        intersection.count = i;\n        eps = gSceneEps * distance;\n        if (abs(d) < eps) break;\n    }\n\n    if (distance < intersection.distance) {\n        intersection.distance = distance;\n        intersection.hit = true;\n        intersection.position = p;\n        intersection.normal = calcNormal(p, map, gSceneEps);\n\n        if (gBallRadius > 0.0 && abs(dBall(p)) < eps) {\n            intersection.baseColor = vec3(0.0);\n            intersection.roughness = 0.0;\n            intersection.metallic = 1.0;\n            intersection.emission = vec3(0.0);\n            intersection.transparent = false;\n            intersection.refractiveIndex = 1.2;\n            intersection.reflectance = 1.0;\n\n            if (gLogoIntensity > 0.0) {\n                intersection.emission = vec3(gLogoIntensity) * revisionLogo(intersection.normal.xy * 0.6, 3.0 * clamp(beat - 174.0, -1000.0, 0.0));\n            }\n        } else if (gSceneId == SCENE_MANDEL) {\n            intersection.baseColor = vec3(gBaseColor);\n            intersection.roughness = gRoughness;\n            intersection.metallic = gMetallic;\n\n            float edge = calcEdge(p);\n            float hue = gEmissiveHue + gEmissiveHueShiftZ * p.z + gEmissiveHueShiftXY * length(p.xy) + gEmissiveHueShiftBeat * beat;\n            intersection.emission = gEmissiveIntensity * hsv2rgb(vec3(hue, 0.8, 1.0)) * pow(edge, gEdgePower) * saturate(cos(beat * gEmissiveSpeed * TAU - mod(0.5 * intersection.position.z, TAU)));\n\n            intersection.transparent = false;\n            intersection.reflectance = 0.0;\n        }\n    }\n}\n\nvoid intersectScene(inout Intersection intersection, inout Ray ray) {\n    intersection.distance = INF;\n    intersectObjects(intersection, ray);\n}\n\n#define FLT_EPS 5.960464478e-8\n\nfloat roughnessToExponent(float roughness) { return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS); }\n\nuniform float gF0;  // 0.95 0 1\nfloat fresnelSchlick(float f0, float cosTheta) { return f0 + (1.0 - f0) * pow((1.0 - cosTheta), 5.0); }\n\nvec3 evalPointLight(inout Intersection i, vec3 v, vec3 lp, vec3 radiance) {\n    vec3 n = i.normal;\n    vec3 p = i.position;\n    vec3 ref = mix(vec3(0.04), i.baseColor, i.metallic);\n\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n\n    vec3 h = normalize(l + v);\n\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), i.metallic) * i.baseColor / PI;\n    float m = roughnessToExponent(i.roughness);\n    vec3 specular = ref * pow(max(0.0, dot(n, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len * len);\n}\n\nvec3 evalDirectionalLight(inout Intersection i, vec3 v, vec3 lightDir, vec3 radiance) {\n    vec3 n = i.normal;\n    vec3 p = i.position;\n    vec3 ref = mix(vec3(0.04), i.baseColor, i.metallic);\n\n    vec3 l = lightDir;\n    vec3 h = normalize(l + v);\n\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), i.metallic) * i.baseColor / PI;\n    float m = roughnessToExponent(i.roughness);\n    vec3 specular = ref * pow(max(0.0, dot(n, h)), m) * (m + 2.0) / (8.0 * PI);\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n));\n}\n\nuniform float gCameraLightIntensity;  // 1 0 10\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat fractal(vec3 p, int n) {\n    float strength = 7.0;\n    float accum = 0.25;\n    float prev = 0.;\n    float tw = 0.;\n    for (int i = 0; i < n; i++) {\n        float mag = dot(p, p);\n        p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n        float w = exp(-float(i) / 7.);\n        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n        tw += w;\n        prev = mag;\n    }\n    return max(0., 5. * accum / tw - .7);\n}\n\nvec3 stars(vec2 uv) {\n    float a = fract(cos(uv.x * 8.3e-2 + uv.y) * 4.7e5);\n    float b = fract(sin(uv.x * 0.3e-2 + uv.y) * 1.0e5);\n    float c = mix(a, b, 0.5);\n    return vec3(pow(c, 30.0));\n}\n\nvec3 skyboxUniverse(vec2 uv) {\n    vec3 col = stars(uv);\n    float b = saturate(cos(TAU * beat / 8.0));\n\n    float f = fractal(vec3(0.2 * uv + vec2(0.3, 0.1), 1.7 + (beat - 192.0) * 0.001), 28);\n    col = mix(col, 0.3 * vec3(1.3 * f * f * f * b, 1.8 * f * f, f), f);\n\n    f = fractal(vec3(0.2 * uv + vec2(0.8, 0.2), 2.7 + (beat - 192.0) * 0.002), 15);\n    col = mix(col, 0.05 * vec3(1.9 * f * f * f, 1.3 * f * f, 1.3 * f * f), f * 0.5);\n\n    return col;\n}\n\nvoid calcRadiance(inout Intersection intersection, inout Ray ray) {\n    intersection.hit = false;\n    intersectScene(intersection, ray);\n\n    if (intersection.hit) {\n        intersection.color = intersection.emission;\n        intersection.color += evalPointLight(intersection, -ray.direction, vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ), gCameraLightIntensity * vec3(80.0, 80.0, 100.0));\n        // intersection.color += evalPointLight(intersection, -ray.direction, vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ + 4.0), vec3(0.0));\n        intersection.color += evalDirectionalLight(intersection, -ray.direction, vec3(-0.48666426339228763, 0.8111071056538127, 0.3244428422615251), vec3(2.0, 1.0, 1.0));\n\n        // fog\n        // intersection.color = mix(intersection.color, vec3(0.6),\n        //                         1.0 - exp(-0.0001 * intersection.distance *\n        //                         intersection.distance *\n        //                         intersection.distance));\n    } else {\n        intersection.color = vec3(0.01);\n\n        if (gSceneId == SCENE_UNIVERSE) {\n            float rdo = ray.direction.y + 0.3;\n            vec2 uv = (ray.direction.xz + ray.direction.xz * (250000.0 - 0.0) / rdo) * 0.000008;\n            intersection.color += skyboxUniverse(uv);\n        }\n    }\n}\n\nvec2 textUv(vec2 uv, float id, vec2 p, float scale) {\n    uv -= p;\n    uv /= scale;\n\n    float offset = 128.0 / 2048.0;\n    uv.x = 0.5 + 0.5 * uv.x;\n    uv.y = 0.5 - 0.5 * (uv.y + 1.0 - offset);\n    uv.y = clamp(uv.y + offset * id, offset * id, offset * (id + 1.0));\n\n    return uv;\n}\n\nvec3 text(vec2 uv) {\n    float id = floor(beat / 4.0);\n    float scale = (id == 0.0) ? 3.0 : 2.0;\n    return texture(iTextTexture, textUv(uv, id, vec2(0.0, 0.0), scale)).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    Camera camera;\n    camera.eye = vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ);\n    camera.target = vec3(gCameraTargetX, gCameraTargetY, gCameraTargetZ);\n    camera.up = vec3(0.0, 1.0, 0.0);  // y-up\n    Ray ray = cameraShootRay(camera, uv);\n\n    vec3 color = vec3(0.0);\n    vec3 reflection = vec3(1.0);\n    Intersection intersection;\n\n    for (int bounce = 0; bounce < 2; bounce++) {\n        calcRadiance(intersection, ray);\n        color += reflection * intersection.color;\n        if (!intersection.hit || intersection.reflectance == 0.0) break;\n        reflection *= intersection.reflectance;\n\n        bool isIncoming = dot(ray.direction, intersection.normal) < 0.0;\n        vec3 orientingNormal = isIncoming ? intersection.normal : -intersection.normal;\n\n        bool isTotalReflection = false;\n        if (intersection.transparent) {\n            float nnt = isIncoming ? 1.0 / intersection.refractiveIndex : intersection.refractiveIndex;\n            ray.origin = intersection.position - orientingNormal * OFFSET;\n            ray.direction = refract(ray.direction, orientingNormal, nnt);\n            isTotalReflection = (ray.direction == vec3(0.0));\n            bounce = 0;\n        }\n\n        if (isTotalReflection || !intersection.transparent) {\n            ray.origin = intersection.position + orientingNormal * OFFSET;\n            vec3 l = reflect(ray.direction, orientingNormal);\n            reflection *= fresnelSchlick(gF0, dot(l, orientingNormal));\n            ray.direction = l;\n        }\n    }\n\n    color += text(uv);\n\n    fragColor = vec4(color, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="uniform float gTonemapExposure;  // 0.1 0.0 2\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nuniform float gVignetteIntensity;   // 1.34 0 3\nuniform float gVignetteSmoothness;  // 2 0 5\nuniform float gVignetteRoundness;   // 1 0 1\n\nuniform float gChromaticAberrationIntensity;  // 0.03 0 0.1\nuniform float gChromaticAberrationDistance;   // 0.45 0 1\n\nfloat vignette(vec2 uv) {\n    vec2 d = abs(uv - 0.5) * gVignetteIntensity;\n    float roundness = (1.0 - gVignetteRoundness) * 6.0 + gVignetteRoundness;\n    d = pow(d, vec2(roundness));\n    return pow(saturate(1.0 - dot(d, d)), gVignetteSmoothness);\n}\n\nvec3 chromaticAberration(vec2 uv) {\n    vec2 d = abs(uv - 0.5);\n    float f = mix(0.5, dot(d, d), gChromaticAberrationDistance);\n    f *= f * gChromaticAberrationIntensity;\n    d = vec2(f);\n\n    vec3 col;\n    col.r = texture(iPrevPass, uv + d).r;\n    col.g = texture(iPrevPass, uv).g;\n    col.b = texture(iPrevPass, uv - d).b;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = chromaticAberration(uv);\n    col *= vignette(uv);\n    col = acesFilm(col * gTonemapExposure);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="float brightness(vec3 c) { return max(max(c.r, c.g), c.b); }\n\nuniform float gBloomThreshold;  // 1.0 0 100\nuniform float gBloomSoftKnee;   // 0.5 0 4\n\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Runtime/Components/BloomComponent.cs#L78-L109\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float softKnee = gBloomSoftKnee;\n    float lthresh = gBloomThreshold;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iPrevPass, uv);\n    vec3 m = color.rgb;\n    float br = brightness(m);\n\n    float knee = lthresh * softKnee + 1e-5f;\n    vec3 curve = vec3(lthresh - knee, knee * 2.0, 0.25 / knee);\n    float rq = clamp(br - curve.x, 0.0, curve.y);\n    rq = curve.z * rq * rq;\n\n    m *= max(rq, br - lthresh) / max(br, 1e-5);\n    fragColor = vec4(m, color.a);\n}"},function(n,e,t){"use strict";t.r(e),e.default="void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    fragColor = vec4(tap4(iPrevPass, uv, texelSize), 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomSpread;  // 1.3 1 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomSpread * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomIntensity;  // 1 0 30\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iBeforeBloom, uv).rgb;\n    vec3 pair = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomIntensity * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="#version 300 es\nprecision mediump float;\nuniform float iSampleRate;\nuniform float iBlockOffset;\n\nvec2 mainSound(float time);\n\nout vec4 outColor;\nvoid main() {\n    float t = iBlockOffset + ((gl_FragCoord.x - 0.5) + (gl_FragCoord.y - 0.5) * 512.0) / iSampleRate;\n    vec2 y = mainSound(t);\n    vec2 v = floor((0.5 + 0.5 * y) * 65536.0);\n    vec2 vl = mod(v, 256.0) / 255.0;\n    vec2 vh = floor(v / 256.0) / 255.0;\n    outColor = vec4(vl.x, vh.x, vl.y, vh.y);\n}\n\n//--------------------\n// ここから下を書き換える\n//--------------------\n\n#define BPM 140.0\n#define PI 3.141592654\n#define TAU 6.283185307\n\nfloat sidechain;\n\n// general functions\nfloat timeToBeat(float t) { return t / 60.0 * BPM; }\nfloat beatToTime(float b) { return b / BPM * 60.0; }\nfloat noteToFreq(float n) { return 440.0 * pow(2.0, (n - 69.0) / 12.0); }\nfloat chord(float n) { return (n < 1.0 ? 55.0 : n < 2.0 ? 58.0 : n < 3.0 ? 62.0 : 65.0); }\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 noise(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// primitive oscillators\nfloat sine(float phase) { return sin(TAU * phase); }\nfloat saw(float phase) { return 2.0 * fract(phase) - 1.0; }\nfloat square(float phase) { return fract(phase) < 0.5 ? -1.0 : 1.0; }\n\n// drums\nfloat kick(float note, float time) {\n    float amp = exp(-1.0 * time);\n    float phase = 15.0 * time - 13.0 * exp(-40.0 * time);\n    return amp * sine(phase);\n}\n\nvec2 hihat(float note, float time) {\n    float amp = exp(-50.0 * time);\n    return amp * noise(time * 100.0).xy;\n}\n\n// synths\nvec2 bass(float note, float time) {\n    float freq = noteToFreq(note);\n    return vec2(saw(freq * time) + sine(freq * time)) / 2.0;\n}\n\nvec2 pad(float note, float time) {\n    float freq = noteToFreq(note);\n    float vib = 0.2 * sine(3.0 * time);\n    return vec2(saw(freq * 0.99 * time + vib), saw(freq * 1.01 * time + vib));\n}\n\nvec2 arp(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = 0.1 * exp(-30.0 * time);\n    float fm = fmamp * square(time * freq * 1.0);\n    float amp = exp(-50.0 * time);\n    return amp * vec2(sine(freq * 0.999 * time + fm), sine(freq * 1.001 * time + fm));\n}\n\nvec2 arpsine(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = 0.02 * exp(-70.0 * time);\n    float fm = fmamp * sine(time * freq * 1.0);\n    float amp = exp(-70.0 * time);\n    return amp * vec2(sine(freq * 0.999 * time + fm), sine(freq * 1.001 * time + fm));\n}\n\nvec2 supersaw(float note, float time) {\n    float amp = exp(-5.0 * time * time);\n    float ret = 0.0;\n    int num = 3;\n    float step = 0.014;\n    int reverbNum = 100;\n\n    for (int i = 0; i < num; i++) {\n        float freq = noteToFreq(note + 12.0 * float(i - num / 2));\n        for (int j = 0; j < reverbNum; j++) {\n            ret += saw(freq * (time - 0.008 * float(j)) * (1.0 + step * float(i - num / 2))) * exp(-3.0 * float(j));\n        }\n    }\n\n    return vec2(0.5 * amp * ret / float(num));\n}\n\n#define NSPC 256\n\n// hard clipping distortion\nfloat dist(float s, float d) { return clamp(s * d, -1.0, 1.0); }\nvec2 dist(vec2 s, float d) { return clamp(s * d, -1.0, 1.0); }\n\n// my resonant lowpass filter's frequency response\nfloat _filter(float h, float cut) {\n    cut -= 20.0;\n    float df = max(h - cut, 0.0), df2 = abs(h - cut);\n    return exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\n// tb303 core\nvec2 synth(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.26;\n    float amp = smoothstep(0.05, 0.0, abs(t - dr - 0.05) - dr) * exp(t * -1.0);\n    float f = noteToFreq(note);\n    float sqr = 1.0;  // smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n\n    float base = f;                    // 50.0 + sin(sin(t * 0.1) * t) * 20.0;\n    float flt = exp(t * -1.5) * 50.0;  // + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 1.0 / h;\n        // inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-1.0 * max(2.0 - h, 0.0));  // + exp(abs(h - flt) * -2.0) * 8.0;\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;  // exp(max(tnote - 0.3, 0.0) * -5.0);\n\n    // o = dist(o, 2.5);\n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 synth1_echo(float note, float time) {\n    vec2 v;\n    v = synth(note, time) * 0.5;  // + synth2(time) * 0.5;\n    float ec = 0.4, fb = 0.6, et = 2.0 / 9.0, tm = 2.0 / 9.0;\n    v += synth(note, time - et) * ec * vec2(1.0, 0.5);\n    ec *= fb;\n    et += tm;\n    v += synth(note, time - et).yx * ec * vec2(0.5, 1.0);\n    ec *= fb;\n    et += tm;\n    v += synth(note, time - et) * ec * vec2(1.0, 0.5);\n    ec *= fb;\n    et += tm;\n    v += synth(note, time - et).yx * ec * vec2(0.5, 1.0);\n    ec *= fb;\n    et += tm;\n\n    return v;\n}\n\n// 1ビートを最大何分割するか。16分音符に対応するなら4\n#define NOTE_DIV 4\n\n#define F(a) a | 4 << 8, a | 4 << 8, a | 4 << 8, a | 4 << 8\n#define E(a) a | 8 << 8, a | 8 << 8\n#define E2(a, b) a | 8 << 8, a | 8 << 8, b | 8 << 8, b | 8 << 8\n#define S(a) a | 16 << 8\n#define S4(a, b, c, d) a | 16 << 8, b | 16 << 8, c | 16 << 8, d | 16 << 8\n\n#define SEQUENCER(beat, time, beatLen, devPat, devLen, notes, development, toneFunc)                    \\\n    int indexOffset = development[int(mod(beat / float(beatLen), float(devLen)))] * beatLen * NOTE_DIV; \\\n                                                                                                        \\\n    int[beatLen * NOTE_DIV] indexes;                                                                    \\\n    for (int i = 0; i < beatLen * NOTE_DIV;) {                                                          \\\n        int div = notes[i + indexOffset] >> 8;                                                          \\\n        if (div == 4) {                                                                                 \\\n            indexes[i + 0] = i;                                                                         \\\n            indexes[i + 1] = i;                                                                         \\\n            indexes[i + 2] = i;                                                                         \\\n            indexes[i + 3] = i;                                                                         \\\n            i += 4;                                                                                     \\\n        } else if (div == 8) {                                                                          \\\n            indexes[i + 0] = i;                                                                         \\\n            indexes[i + 1] = i;                                                                         \\\n            i += 2;                                                                                     \\\n        } else if (div == 16) {                                                                         \\\n            indexes[i + 0] = i;                                                                         \\\n            i += 1;                                                                                     \\\n        }                                                                                               \\\n    }                                                                                                   \\\n                                                                                                        \\\n    float indexFloat = mod(beat * float(NOTE_DIV), float(beatLen * NOTE_DIV));                          \\\n    int index = int(indexFloat);                                                                        \\\n    int note = notes[index + indexOffset] & 255;                                                        \\\n    float localTime = beatToTime((indexFloat - float(indexes[index])) / float(NOTE_DIV));               \\\n    float amp = (note == 0) ? 0.0 : 1.0;                                                                \\\n    vec2 ret = vec2(toneFunc(float(note), localTime) * amp);\n\nvec2 arp1(float beat, float time) {\n// 1つの展開のビート数\n#define ARP1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP1_DEV_PAT 2\n\n// 展開の長さ\n#define ARP1_DEV_LEN 4\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP1_BEAT_LEN * NOTE_DIV * ARP1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(57, 0, 59, 0),\n\n        // 2\n        S4(60, 0, 64, 0),\n\n        // 3\n        S4(67, 0, 69, 0),\n\n        // 4\n        S4(71, 0, 74, 0),\n\n        // 5\n        S4(57, 0, 59, 0),\n\n        // 6\n        S4(60, 0, 64, 0),\n\n        // 7\n        S4(67, 0, 69, 0),\n\n        // 8\n        S4(71, 0, 74, 0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(57, 0, 59, 0),\n\n        // 2\n        S4(60, 0, 64, 0),\n\n        // 3\n        S4(67, 0, 69, 0),\n\n        // 4\n        S4(71, 0, 74, 0),\n\n        // 5\n        S4(57, 0, 59, 0),\n\n        // 6\n        S4(60, 0, 64, 0),\n\n        // 7\n        S4(67, 0, 69, 0),\n\n        // 8\n        S4(71, 0, 74, 0));\n\n    // 展開\n    int[ARP1_DEV_LEN] development = int[](0, 0, 1, 1);\n\n    SEQUENCER(beat, time, ARP1_BEAT_LEN, ARP1_DEV_PAT, ARP1_DEV_LEN, notes, development, arp)\n    return ret;\n}\n\nvec2 arp2(float beat, float time) {\n// 1つの展開のビート数\n#define ARP2_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP2_DEV_PAT 2\n\n// 展開の長さ\n#define ARP2_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP2_BEAT_LEN * NOTE_DIV * ARP2_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(0, 69, 0, 71),\n\n        // 2\n        S4(0, 72, 0, 76),\n\n        // 3\n        S4(0, 79, 0, 81),\n\n        // 4\n        S4(0, 83, 0, 86),\n\n        // 5\n        S4(0, 69, 0, 71),\n\n        // 6\n        S4(0, 72, 0, 76),\n\n        // 7\n        S4(0, 79, 0, 81),\n\n        // 8\n        S4(0, 83, 0, 86),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(0, 69, 0, 71),\n\n        // 2\n        S4(0, 72, 0, 76),\n\n        // 3\n        S4(0, 79, 0, 81),\n\n        // 4\n        S4(0, 83, 0, 86),\n\n        // 5\n        S4(0, 69, 0, 71),\n\n        // 6\n        S4(0, 72, 0, 76),\n\n        // 7\n        S4(0, 79, 0, 81),\n\n        // 8\n        S4(0, 83, 0, 86));\n\n    // 展開\n    int[ARP2_DEV_LEN] development = int[](0, 0, 0, 0, 1, 1, 1, 1);\n\n    SEQUENCER(beat, time, ARP2_BEAT_LEN, ARP2_DEV_PAT, ARP2_DEV_LEN, notes, development, arp)\n    return ret;\n}\n\nvec2 arp3(float beat, float time) {\n// 1つの展開のビート数\n#define ARP3_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP3_DEV_PAT 2\n\n// 展開の長さ\n#define ARP3_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP3_BEAT_LEN * NOTE_DIV * ARP3_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(72, 60, 55, 64),\n\n        // 2\n        S4(0, 0, 0, 0),\n\n        // 3\n        S4(67, 55, 64, 55),\n\n        // 4\n        S4(0, 0, 0, 0),\n\n        // 5\n        S4(72, 60, 55, 64),\n\n        // 6\n        S4(0, 0, 0, 0),\n\n        // 7\n        S4(67, 55, 64, 55),\n\n        // 8\n        S4(0, 0, 0, 0),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(72, 60, 55, 64),\n\n        // 2\n        S4(0, 0, 0, 0),\n\n        // 3\n        S4(67, 55, 64, 55),\n\n        // 4\n        S4(0, 0, 0, 0),\n\n        // 5\n        S4(72, 60, 55, 64),\n\n        // 6\n        S4(0, 0, 0, 0),\n\n        // 7\n        S4(67, 55, 64, 55),\n\n        // 8\n        S4(0, 0, 0, 0));\n\n    // 展開\n    int[ARP3_DEV_LEN] development = int[](0, 0, 0, 0, 1, 1, 1, 1);\n\n    SEQUENCER(beat, time, ARP3_BEAT_LEN, ARP3_DEV_PAT, ARP3_DEV_LEN, notes, development, arpsine)\n    return ret;\n}\n\nvec2 arp4(float beat, float time) {\n// 1つの展開のビート数\n#define ARP4_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define ARP4_DEV_PAT 2\n\n// 展開の長さ\n#define ARP4_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[ARP4_BEAT_LEN * NOTE_DIV * ARP4_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        S4(0, 0, 0, 0),\n\n        // 2\n        S4(67, 60, 72, 55),\n\n        // 3\n        S4(0, 0, 0, 0),\n\n        // 4\n        S4(67, 60, 79, 62),\n\n        // 5\n        S4(0, 0, 0, 0),\n\n        // 6\n        S4(67, 60, 72, 55),\n\n        // 7\n        S4(0, 0, 0, 0),\n\n        // 8\n        S4(67, 60, 79, 62),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        S4(0, 0, 0, 0),\n\n        // 2\n        S4(67, 60, 72, 55),\n\n        // 3\n        S4(0, 0, 0, 0),\n\n        // 4\n        S4(67, 60, 79, 62),\n\n        // 5\n        S4(0, 0, 0, 0),\n\n        // 6\n        S4(67, 60, 72, 55),\n\n        // 7\n        S4(0, 0, 0, 0),\n\n        // 8\n        S4(67, 60, 79, 62));\n\n    // 展開\n    int[ARP4_DEV_LEN] development = int[](0, 0, 0, 0, 1, 1, 1, 1);\n\n    SEQUENCER(beat, time, ARP4_BEAT_LEN, ARP4_DEV_PAT, ARP4_DEV_LEN, notes, development, arpsine)\n    return ret;\n}\n\nvec2 kick1(float beat, float time) {\n// 1つの展開のビート数\n#define KICK1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define KICK1_DEV_PAT 2\n\n// 展開の長さ\n#define KICK1_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[KICK1_BEAT_LEN * NOTE_DIV * KICK1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(0),\n\n        // 3\n        F(0),\n\n        // 4\n        E2(0, 1),\n\n        // 5\n        F(1),\n\n        // 6\n        F(0),\n\n        // 7\n        F(0),\n\n        // 8\n        F(1),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(1),\n\n        // 2\n        F(1),\n\n        // 3\n        F(1),\n\n        // 4\n        F(1),\n\n        // 5\n        F(1),\n\n        // 6\n        F(1),\n\n        // 7\n        F(1),\n\n        // 8\n        F(1));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[KICK1_DEV_LEN] development = int[](0, 0, 0, 0, 1, 1, 1, 1);\n\n    SEQUENCER(beat, time, KICK1_BEAT_LEN, KICK1_DEV_PAT, KICK1_DEV_LEN, notes, development, kick)\n\n    if (beat < 8.0) {\n        sidechain = smoothstep(0.0, 0.4, localTime);\n    } else {\n        sidechain = smoothstep(0.0, 0.2, localTime);\n    }\n\n    return ret;\n}\n\nvec2 testSupersaw(float beat, float time) {\n// 1つの展開のビート数\n#define KICK1_BEAT_LEN 8\n\n// 展開のパターンの種類\n#define KICK1_DEV_PAT 2\n\n// 展開の長さ\n#define KICK1_DEV_LEN 8\n\n    // ノート番号\n    // F: 4分音符\n    // E: 8分音符\n    // S: 16分音符\n    // ノート番号0は休符\n    int[KICK1_BEAT_LEN * NOTE_DIV * KICK1_DEV_PAT] notes = int[](\n        //\n        // 展開0\n        //\n\n        // 1\n        F(64),\n\n        // 2\n        F(64),\n\n        // 3\n        F(64),\n\n        // 4\n        F(64),\n\n        // 5\n        F(64),\n\n        // 6\n        F(64),\n\n        // 7\n        F(64),\n\n        // 8\n        F(64),\n\n        //\n        // 展開1（とりあえず今は展開0と同じ）\n        //\n\n        // 1\n        F(67),\n\n        // 2\n        F(67),\n\n        // 3\n        F(67),\n\n        // 4\n        F(67),\n\n        // 5\n        F(67),\n\n        // 6\n        F(67),\n\n        // 7\n        F(67),\n\n        // 8\n        F(67));\n\n    // 展開 #define KICK1_DEV_LEN 8　変える\n    int[KICK1_DEV_LEN] development = int[](0, 0, 0, 0, 1, 1, 1, 1);\n\n    SEQUENCER(beat, time, KICK1_BEAT_LEN, KICK1_DEV_PAT, KICK1_DEV_LEN, notes, development, supersaw)\n    return ret;\n}\n\nvec2 mainSound(float time) {\n    float beat = timeToBeat(time);\n    vec2 ret = vec2(0.0);\n\n    // kick\n    ret += kick1(beat, time);\n\n    // hihat\n    float hihatTime = beatToTime(mod(beat + 0.5, 1.0));\n    ret += 0.5 * hihat(1.0, hihatTime);\n\n    // bass\n    float bassNote = chord(0.0) - 22.0;\n    ret += sidechain * 0.3 * bass(bassNote, time);\n\n    // chord\n    ret += sidechain * 0.0 * vec2(pad(chord(0.0), time) + pad(chord(1.0), time) + pad(chord(2.0), time) + pad(chord(3.0), time)) / 4.0;\n\n    // arp\n    ret += vec2(0.2, 0.0) * arp1(beat, time);  // L70 R0\n    ret += vec2(0.0, 0.2) * arp2(beat, time);  // R70 R0\n    ret += vec2(0.1, 0.6) * arp3(beat, time);  // R70 R0 サイン波のアルペジオ\n    ret += vec2(0.6, 0.1) * arp4(beat, time);  // R70 R0 サイン波のアルペジオ\n\n    // supersaw以外の音をMute\n    // ret = vec2(0.0);\n\n    // supersawのテスト\n    ret += sidechain * testSupersaw(beat, time);\n\n    return clamp(ret, -1.0, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),e.default="body{background-color:#000;margin:0;padding:0;color:#fff}canvas{display:block;position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}#c{display:none}p{font-size:100px}"},function(n,e,t){"use strict";t.r(e);var i=function(n,e,t,i){return new(t||(t=Promise))((function(o,a){function r(n){try{f(i.next(n))}catch(n){a(n)}}function s(n){try{f(i.throw(n))}catch(n){a(n)}}function f(n){var e;n.done?o(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(r,s)}f((i=i.apply(n,e||[])).next())}))},o=function(n,e){var t,i,o,a,r={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;r;)try{if(t=1,i&&(o=2&a[0]?i.return:a[0]?i.throw||((o=i.return)&&o.call(i),0):i.next)&&!(o=o.call(i,a[1])).done)return o;switch(i=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return r.label++,{value:a[1],done:!1};case 5:r.label++,i=a[1],a=[0];continue;case 7:a=r.ops.pop(),r.trys.pop();continue;default:if(!(o=(o=r.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){r=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){r.label=a[1];break}if(6===a[0]&&r.label<o[1]){r.label=o[1],o=a;break}if(o&&r.label<o[2]){r.label=o[2],r.ops.push(a);break}o[2]&&r.ops.pop(),r.trys.pop();continue}a=e.call(n,r)}catch(n){a=[6,n],i=0}finally{t=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}},a=0,r=1,s=2,f=3,l=4,c=function(){},u=function(n,e,t,u,m,d,v,p,g,E,h,x){var y=this;this.play=function(){y.timeLength=n,y.isPlaying=!0,y.needsUpdate=!1,y.time=0,y.uniformArray=[],y.uniforms={};var b=y.audioContext=new window.AudioContext,T=y.canvas=document.createElement("canvas");T.width=window.innerWidth,T.height=window.innerHeight,window.document.body.appendChild(T);var _=T.getContext("webgl2",{preserveDrawingBuffer:!0});if(_)if(_.getExtension("EXT_color_buffer_float"))if(_.getExtension("OES_texture_float_linear")){_.enable(_.CULL_FACE);var R=[[1,1],[-1,1],[1,-1],[-1,-1]],S=new Float32Array([].concat.apply([],R)),A=_.createBuffer();_.bindBuffer(_.ARRAY_BUFFER,A),_.bufferData(_.ARRAY_BUFFER,S,_.STATIC_DRAW),_.bindBuffer(_.ARRAY_BUFFER,null);var F=[[0,1,2],[3,2,1]],w=new Uint16Array([].concat.apply([],F)),C=_.createBuffer();_.bindBuffer(_.ELEMENT_ARRAY_BUFFER,C),_.bufferData(_.ELEMENT_ARRAY_BUFFER,w,_.STATIC_DRAW),_.bindBuffer(_.ELEMENT_ARRAY_BUFFER,null);var P=_.createVertexArray(),B=x(_),I=(t.split("\n").length,function(n,e){var t=_.createShader(e);if(_.shaderSource(t,n),_.compileShader(t),!_.getShaderParameter(t,_.COMPILE_STATUS)){var i=_.getShaderInfoLog(t);console.log(n,i)}return t}),D=function(n){var t=[I(e,_.VERTEX_SHADER),I(n,_.FRAGMENT_SHADER)],i=_.createProgram();return t.forEach((function(n){return _.attachShader(i,n)})),_.linkProgram(i),_.getProgramParameter(i,_.LINK_STATUS)||console.log(_.getProgramInfoLog(i)),i},N=function(n,e,t,i){!function(n){_.bindVertexArray(P),_.bindBuffer(_.ARRAY_BUFFER,A),_.bindBuffer(_.ELEMENT_ARRAY_BUFFER,C);var e=_.getAttribLocation(n,"vert2d"),t=_.FLOAT,i=R[0].length,o=i*Float32Array.BYTES_PER_ELEMENT;_.enableVertexAttribArray(e),_.vertexAttribPointer(e,i,t,!1,o,0),_.bindVertexArray(null)}(n);var o=new c;if(o.program=n,o.index=e,o.type=t,o.scale=i,o.uniforms={iResolution:{type:"v3",value:[T.width*o.scale,T.height*o.scale,0]},iTime:{type:"f",value:0},iPrevPass:{type:"t",value:Math.max(o.index-1,0)},iBeforeBloom:{type:"t",value:Math.max(m-1,0)},iBlockOffset:{type:"f",value:0},iSampleRate:{type:"f",value:b.sampleRate},iTextTexture:{type:"t",value:0}},t===f){var a=e-(m+d);o.uniforms.iPairBloomDown={type:"t",value:e-2*a}}return y.uniformArray.forEach((function(n){o.uniforms[n.key]={type:"number"==typeof n.initValue?"f":"v3",value:n.initValue}})),o.locations=function(n){var e={};return Object.keys(n.uniforms).forEach((function(t){e[t]=_.getUniformLocation(n.program,t)})),e}(o),function(n){if(n.type!==r){var e=n.uniforms.iResolution.value[0],t=n.uniforms.iResolution.value[1],i=_.FLOAT,o=_.RGBA32F,a=_.LINEAR;n.type===l&&(e=512,t=512,i=_.UNSIGNED_BYTE,o=_.RGBA,a=_.NEAREST),n.frameBuffer=_.createFramebuffer(),_.bindFramebuffer(_.FRAMEBUFFER,n.frameBuffer),n.texture=_.createTexture(),_.bindTexture(_.TEXTURE_2D,n.texture),_.texImage2D(_.TEXTURE_2D,0,o,e,t,0,_.RGBA,i,null),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MAG_FILTER,a),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MIN_FILTER,a),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_WRAP_S,_.CLAMP_TO_EDGE),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_WRAP_T,_.CLAMP_TO_EDGE),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_2D,n.texture,0),_.bindTexture(_.TEXTURE_2D,null),_.bindRenderbuffer(_.RENDERBUFFER,null),_.bindFramebuffer(_.FRAMEBUFFER,null)}}(o),o},L=function(n){_.useProgram(n.program),_.bindFramebuffer(_.FRAMEBUFFER,n.frameBuffer),_.clear(_.COLOR_BUFFER_BIT|_.DEPTH_BUFFER_BIT);for(var e=0,t=Object.entries(n.uniforms);e<t.length;e++){var i=t[e],o=i[0],a=i[1],r={f:_.uniform1f,v3:_.uniform3fv},s={iPrevPass:0,iBeforeBloom:1,iPairBloomDown:2,iTextTexture:3};"t"===a.type?(_.activeTexture(_.TEXTURE0+s[o]),"iTextTexture"===o?_.bindTexture(_.TEXTURE_2D,B):_.bindTexture(_.TEXTURE_2D,V[a.value].texture),_.uniform1i(n.locations[o],s[o])):r[a.type].call(_,n.locations[o],a.value)}_.bindVertexArray(P);var f=0*F[0].length;_.drawElements(_.TRIANGLES,w.length,_.UNSIGNED_SHORT,f);var l=_.getError();l!==_.NO_ERROR&&console.log(l),_.bindVertexArray(null),_.useProgram(null)};y.playSound=function(){y.audioSource.start(y.audioContext.currentTime,y.time%y.timeLength)},y.render=function(){V.forEach((function(n){n.uniforms.iTime.value=y.time;for(var e=0,t=Object.entries(y.uniforms);e<t.length;e++){var i=t[e],o=i[0],a=i[1];n.uniforms[o].value="number"==typeof a?a:[a[0]/255,a[1]/255,a[2]/255]}L(n)}))};var U=function(n){for(var e,t=/uniform (float|vec3) (g.+);\s*(\/\/ ([\-\d\.-]+))?( ([\-\d\.]+) ([\-\d\.]+))?/g;null!==(e=t.exec(n));){var i=void 0;i="float"===e[1]?{key:e[2],initValue:void 0!==e[4]?parseFloat(e[4]):0,min:void 0!==e[6]?parseFloat(e[6]):0,max:void 0!==e[7]?parseFloat(e[7]):1}:{key:e[2],initValue:[parseFloat(e[4]),parseFloat(e[6]),parseFloat(e[7])]},y.uniformArray.push(i),y.uniforms[i.key]=i.initValue}};U(t),u.forEach((function(n){U(n)})),U(v),U(p),U(g),U(E);var V=[],M=0;u.forEach((function(n,e,i){if(e===m){V.push(N(D(t+v),M,s,1)),M++;for(var o=1,l=0;l<d;l++)o*=.5,V.push(N(D(t+p),M,s,o)),M++;for(l=0;l<d-1;l++)o*=2,V.push(N(D(t+g),M,f,o)),M++;V.push(N(D(t+E),M,f,1)),M++}V.push(N(D(t+n),M,e<i.length-1?a:r,1)),M++})),function(){for(var e=b.createBuffer(2,b.sampleRate*n,b.sampleRate),t=b.sampleRate*n/262144,a=D(h),r=N(a,0,l,1),s=0;s<t;s++){r.uniforms.iBlockOffset.value=262144*s/b.sampleRate,L(r);var f=new Uint8Array(1048576);_.readPixels(0,0,512,512,_.RGBA,_.UNSIGNED_BYTE,f);for(var c=e.getChannelData(0),u=e.getChannelData(1),m=0;m<262144;m++)c[262144*s+m]=(f[4*m+0]+256*f[4*m+1])/65535*2-1,u[262144*s+m]=(f[4*m+2]+256*f[4*m+3])/65535*2-1}y.audioSource=b.createBufferSource(),i(y,void 0,void 0,(function(){var n,e;return o(this,(function(t){switch(t.label){case 0:return[4,fetch("200319_bgm_sketch.aac")];case 1:return[4,t.sent().arrayBuffer()];case 2:return n=t.sent(),e=this.audioSource,[4,b.decodeAudioData(n)];case 3:return e.buffer=t.sent(),[2]}}))})),y.audioSource.loop=!0,y.audioSource.connect(b.destination)}();var z=0,q=null,O=function(n){requestAnimationFrame(O),q||(q=n);var e=.001*(n-z);(y.isPlaying||y.needsUpdate)&&(null!=y.onRender&&y.onRender(y.time,e),y.render(),y.time=.001*(n-q)),y.needsUpdate=!1,z=n};requestAnimationFrame(O)}else alert("need OES_texture_float_linear");else alert("need EXT_color_buffer_float");else console.log("WebGL 2 is not supported...")}},m=function(n,e,t){return n*(1-t)+e*t},d=function(n,e,t){return n<e?e:n>t?t:n},v=function(n){return d(n,0,1)},p=function(n,e,t,i,o){return d(i+(n-e)*(o-i)/(t-e),i,o)},g=function(n,e){return Math.sin(n+e)+.5*Math.sin(2*n+e)+.25*Math.sin(4*n+e)},E=function(){function n(n,e,t){this.x=n,this.y=e,this.z=t}return n.prototype.add=function(e){return new n(this.x+e.x,this.y+e.y,this.z+e.z)},n.prototype.mul=function(e){return new n(this.x*e.x,this.y*e.y,this.z*e.z)},n.prototype.scale=function(e){return new n(this.x*e,this.y*e,this.z*e)},n.mix=function(e,t,i){return new n(m(e.x,t.x,i),m(e.y,t.y,i),m(e.z,t.z,i))},n.fbm=function(e){return new n(g(11431,e),g(23123,e),g(87034,e))},n}(),h=new u(96,t(0).default,t(1).default,[t(2).default,t(3).default],1,5,t(4).default,t(5).default,t(6).default,t(7).default,t(8).default,(function(n){var e=document.createElement("canvas"),t=e.getContext("2d");e.width=2048,e.height=2048,t.font="110px arial",t.textAlign="center",t.textBaseline="middle",t.fillStyle="white",t.clearRect(0,0,e.width,e.height),["RE: SIMULATED","Graphics by gam0022","Music by saddakey","FMS-Cat","Ctrl-Alt-Test","RGBA & TBC","CNCD & Fairlight","0x4015 & YET1","kaneta🐛","gaz"].forEach((function(n,i){t.fillText(n,e.width/2,64+128*i)}));var i=n.createTexture();return n.bindTexture(n.TEXTURE_2D,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),i})),x=function(){function n(n){this.input=n,this.begin=0,this.done=!1}return n.prototype.then=function(n,e){return this.done||this.input<this.begin?this:this.input>this.begin+n?(this.begin+=n,this):(e(this.input-this.begin),this.done=!0,this)},n}();window.addEventListener("load",(function(n){var e=document.createElement("style");e.innerText=t(9).default,document.head.appendChild(e);var i=document.createElement("p");document.body.appendChild(i),i.innerHTML="click me!",i.onclick=function(){document.body.requestFullscreen().then((function(){h.onRender=function(n,e){!function(n,e,t){var i=140*n/60,o=new E(0,0,10),a=new E(0,0,0),r=new E(0,0,-10);h.uniformArray.forEach((function(n){h.uniforms[n.key]=n.initValue})),new x(i).then(8,(function(n){h.uniforms.gTonemapExposure=.2,o=new E(0,.2,-13-.1*n).add(E.fbm(n).scale(.01)),a=new E(0,0,0),h.uniforms.gMandelboxScale=1.8,h.uniforms.gCameraLightIntensity=.4,h.uniforms.gEmissiveIntensity=0,h.uniforms.gSceneEps=.003,h.uniforms.gBallRadius=0})).then(8,(function(n){h.uniforms.gTonemapExposure=.2,o=new E(0,.2,-17-.1*n).add(E.fbm(n).scale(.01)),a=new E(0,0,0),h.uniforms.gMandelboxScale=1.8,h.uniforms.gCameraLightIntensity=1.2,h.uniforms.gEmissiveIntensity=0,h.uniforms.gBallRadius=0})).then(16,(function(n){o=new E(-.08503080276580499,1.3346599987007965,-15.01732922836809).add(E.fbm(n).scale(.001)),a=new E(.784904810273659,3.3444920877098543,7.36034431847018),h.uniforms.gCameraFov=(n<8?2:5)+.05*n,h.uniforms.gMandelboxScale=2.5010184112784057,h.uniforms.gCameraLightIntensity=1.4,h.uniforms.gEmissiveIntensity=0,h.uniforms.gSceneEps=.0002645177773046626,h.uniforms.gBallRadius=0})).then(16,(function(n){o=new E(.05336320223924196,3.2510840695253322+.01*n,-5.0872681523358665).add(E.fbm(n).scale(.001)),a=new E(-.21247566790275868,3.469965904363116,-.4828265949411093),h.uniforms.gCameraFov=22.457765885219057,h.uniforms.gMandelboxScale=2.9815487838971206,h.uniforms.gCameraLightIntensity=.01,h.uniforms.gEmissiveIntensity=1.8818642917049402,h.uniforms.gEdgeEps=1e-4,h.uniforms.gEmissiveSpeed=.5,h.uniforms.gBallRadius=0})).then(16,(function(n){o=new E(-.009156083313678657,3.548031114215368,.5*n-5.16851465075457).add(E.fbm(n).scale(.005)),a=o.add(new E(.1,.1,1)),h.uniforms.gCameraFov=23,h.uniforms.gMandelboxScale=2.9815487838971206,h.uniforms.gCameraLightIntensity=.003,h.uniforms.gEdgeEps=1e-4,h.uniforms.gEmissiveIntensity=1.8818642917049402,h.uniforms.gEmissiveSpeed=.5,h.uniforms.gBallRadius=0})).then(16,(function(n){var e=new E(0,2.8,-8),t=new E(0,0,-32);o=E.mix(e,t,v(.1*n)),a=new E(0,0,0),h.uniforms.gMandelboxScale=1+.02*n,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=0})).then(16,(function(n){r.z=-10-.2*n,o=new E(0,0,.2+.003*n*n).add(r).add(E.fbm(n).scale(.001)),a=r,h.uniforms.gMandelboxScale=1.32+0*Math.sin(n),h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.2*n,o=new E(-.2-.05*n,.2+.05*n,1+.05*n).add(r).add(E.fbm(n).scale(.001)),a=r,h.uniforms.gMandelboxScale=1.32-.02*n,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.5*n,o=new E(1,-.2,-14).add(E.fbm(n).scale(.001)),a=r.add(new E(-.15,0,0)),h.uniforms.gMandelboxScale=1.244560757418114,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.5*n,o=new E(.4,.5,-8).add(E.fbm(n).scale(.001)),a=r.add(new E(-.15,-.15,0)),h.uniforms.gMandelboxScale=1.244560757418114,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1})).then(8,(function(n){r.z=-10-.5*n,o=new E(0,0,-1).add(r).add(E.fbm(n).scale(.001)),a=r.add(new E(-.15,0,0)),h.uniforms.gCameraFov=43,h.uniforms.gMandelboxScale=1.2,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1,h.uniforms.gEmissiveHueShiftBeat=.5})).then(16,(function(n){r.z=-20,o=new E(0,0,-10).add(E.fbm(n).scale(.01)),a=o.add(new E(0,0,-1)),h.uniforms.gMandelboxScale=1.2-.01*n,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1,h.uniforms.gEmissiveHueShiftBeat=.5,h.uniforms.gEmissiveHueShiftZ=.3,h.uniforms.gEmissiveHueShiftXY=.3})).then(16,(function(n){r.z=10,o=new E(0,0,-8-2*n).add(E.fbm(n).scale(.01)),a=o.add(new E(0,0,1)),h.uniforms.gMandelboxScale=1.2-.0125*n,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1,h.uniforms.gFoldRotate=8,h.uniforms.gEmissiveHueShiftBeat=.5,h.uniforms.gEmissiveHueShiftZ=.3,h.uniforms.gEmissiveHueShiftXY=.3})).then(16,(function(n){r.z=-10-.2*n,o=new E(0,0,1+.003*n*n).add(r),a=r.scale(1),h.uniforms.gMandelboxScale=1.32-.02*n,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1,h.uniforms.gLogoIntensity=p(n,4,8,.02,2),h.uniforms.gF0=0,h.uniforms.gChromaticAberrationIntensity=.04+.1*v(Math.sin(2*Math.PI*n)),h.uniforms.gEmissiveHueShiftBeat=.5})).then(8,(function(n){r.z=-10-.2*n,o=new E(-.2-.05*n,.2+.05*n,1+.05*n).add(r),a=r,h.uniforms.gMandelboxScale=1,h.uniforms.gEmissiveIntensity=6,h.uniforms.gBallRadius=.1,h.uniforms.gLogoIntensity=1,h.uniforms.gF0=0,h.uniforms.gChromaticAberrationIntensity=.06+.1*Math.sin(10*n),h.uniforms.gEmissiveHueShiftBeat=.5})).then(8,(function(n){o=new E(0,0,25).add(E.fbm(n).scale(.01)),a=new E(0,0,0),h.uniforms.gMandelboxScale=1.2,h.uniforms.gEmissiveIntensity=6,h.uniforms.gChromaticAberrationIntensity=.04,h.uniforms.gEmissiveHueShiftBeat=1,h.uniforms.gEmissiveHueShiftZ=.3})).then(32,(function(n){h.uniforms.gSceneId=1,h.uniforms.gSceneEps=.003,h.uniforms.gTonemapExposure=1,o=new E(0,0,10-n),a=new E(0,0,0),r.z=0,h.uniforms.gLogoIntensity=1})),h.uniforms.gBallZ=r.z,h.uniforms.gCameraEyeX=o.x,h.uniforms.gCameraEyeY=o.y,h.uniforms.gCameraEyeZ=o.z,h.uniforms.gCameraTargetX=a.x,h.uniforms.gCameraTargetY=a.y,h.uniforms.gCameraTargetZ=a.z}(n)},h.play(),h.playSound()}))}}),!1)}]);